
Міністерство освіти і науки України Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук Кафедра програмної інженерії
КУРСОВА РОБОТА ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення» Тема роботи: Програмна система для медико-фармацевтичної колаборації

Студент гр. ПЗПІ-21-5	  	Хруб Ю.К.
(підпис)
 
Керівник роботи
 


(підпис)
Роботу захищено «
 
ст.викл. Сокорчук І.П.

»	2024 р.
 
 
з оцінкою  	


Комісія:	 	доц. Лещинський В.О.
(підпис)
 	доц. Лещинська І.О.
(підпис)
 	ст.викл. Сокорчук І.П.
(підпис)

Харків 2024 р.
 
Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6		 Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ


 	Хрубу Юнісу Кахеру	
1.	Тема	роботи:	«Програмна система для медико-фармацевтичної колаборації»		
2.	Термін узгодження завдання курсової роботи « 25	»    березня	2024 р.
3.	Термін здачі студентом закінченої роботи «   25  »    червня	2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити: авторизація, додавання аналізів, констатація показників здоров’я, редагування реєстру препаратів, ведення реєстру препаратів та користувачів різних рівнів. Використовувати ОС Windows 10, СКБД Microsoft SQL Server, фреймворк ASP.NET Core, головна мова програмування C#, середовище розробки Microsoft Visual Studio	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень схема бази даних, діаграми прецедентів, діаграми розгортання, діаграми пакетів, діаграми взаємодій, діаграми діяльності, діаграми компонентів, діаграма потоку даних, інтерфейс головної сторінки	
 

КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація програмного проекту	15.04.2024	виконано
2	Проектування програмного проекту	20.04.2024	виконано
3	Кодування програмного проекту	04.05.2024	виконано
4	Оформлення пояснювальної записки	18.05.2024	виконано
5	Захист курсової роботи	25.06.2024	виконано

Дата видачі завдання «   25	»         березня	2024 р.
 
Керівник
________ст.викл. Сокорчук І.П.(підпис)

Завдання прийняв до виконання
ст.гр. ПЗПІ-21-5	  	
________Хруб Ю.К. (підпис)
 

РЕФЕРАТ


	Пояснювальна записка до курсової роботи: 63 с., 18 рис., 5 додатків, 4 джерела.
	БАЗА ДАНИХ, КОРИСТУВАЛЬНИЦЬКИЙ ІНТЕРФЕЙС UI, МОВА
	ПРОГРАМУВАННЯ C#, МАСШАТАБОВАНА АРХІТЕКТУРА, ПЛАТФОРМА ЦИФРОВІЗАЦІЇ МЕДИЦИНИ ТА ФАРМАЦЕВТИКИ, ПЛАТФОРМА .NET, ПРОГРАМА VISUAL STUDIO, CУБД MICROSOFT SQL SERVER.
	Мета роботи – розробка програмного додатку “Medoxity”, який надасть можливість медичним працівникам та звичайним користувачам отримувати доступ до медичної інформації, взаємодіяти один з одним та розвивати професійні мережі.	Методи вирішення задачі формуються на системі управління баз даних Microsoft SQL Server, використанні технології Entity Framework Core, середи розробки Microsoft Visual Studio, для серверної частини застосунку було використано ASP.NET, для програмування веб частини системи було використано Razor Pages та JavaScript для надсилання запитів та отримання відповідей на сервер,для програмування мобайл частини системи було використано  мову програмування Kotlin.
	Розроблена програмна система “Medoxity” дозволяє зареєструвати нових користувачів, отримувати та оновлювати інформацію про лікарські засоби, додавати та переглядати коментарі, рейтинги і документи. Програмна система цифровізує фароммедичні аспекти та інформацію.
	Як результат, було створено ефективний програмний продукт “Medoxity”, який включає інформаційну систему для медичних працівників та звичайних користувачів. Завдяки цій платформі користувачі можуть швидко знаходити інформацію про лікарські засоби, обмінюватися знаннями та досвідом, а також розвивати свої професійні мережі. Програмний додаток виконує всі поставлені задачі та повністю готовий до використання.


ЗМІСТ


	ВСТУП	8
	1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДЕМЕТНОЇ ГАЛУЗІ	10
	1.1 Аналіз предметної області	10
	1.2 Аналіз аналогів	14
	1.3 Концептуальне моделювання предметної області	16
	2 ПОСТАНОВКА ЗАДАЧІ	19
	2.1 Опис задачі	19
	2.2 Функціональність	19
	2.3 Припущення та залежності	20
	3 СЕРВЕРНА ЧАСТИНА СИСТЕМИ	22
	3.1 Архітектура	22
	3.2 Побудова діаграми прецедентів	24
	3.3 Побудова діаграми розгортання	26
	3.4 Специфікація REST	27
	3.5 Тестування	30
   	3.6 Побудова діаграми пакетів	31
	4 IOT ЧАСТИНА СИСТЕМИ	33
	4.1 Архітектура	33
	4.2 Побудова діаграми прецедентів	34
	4.3 Побудова діаграми пакетів	35
	4.4 Обробка даних	36
	5 ВЕБ ЧАСТИНА СИСТЕМИ	38
	5.1 Інтерфейс	38
	5.2 Побудова діаграми пакетів	41
	6  МОБІЛЬНА ЧАСТИНА СИСТЕМИ	43
	6.1 Архітектура та інтерфейс	43
	6.2 Побудова діаграми прецедентів	45
	6.3 Побудова діаграми діяльності	47
	6.4 Побудова діаграми пакетів	48
	ВИСНОВКИ	50
	ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	52
	ДОДАТОК А	53
	ДОДАТОК Б	56
	ДОДАТОК В	59
	ДОДАТОК Г	60
	ДОДАТОК Д	63


ВСТУП


	Сучасний світ потребує швидкого та ефективного доступу до медичної інформації як для професіоналів, так і для звичайних користувачів. Це забезпечує можливість оперативного прийняття рішень та підвищення рівня медичного обслуговування. У зв'язку з цим, було розроблено платформу “Medoxity”, яка допомагає медичним працівникам та користувачам знаходити необхідну інформацію про лікарські засоби, обмінюватися знаннями та досвідом, а також розвивати професійні мережі.
	Програма “Medoxity” – це додаток, який містить інформаційну систему для медичних працівників та звичайних користувачів. Додаток включає інформацію про лікарські засоби, дозволяє обмінюватися знаннями та досвідом між лікарями та фармацевтами, а також сприяє розвитку професійних мереж. Завдяки цій платформі користувачі можуть швидко знайти необхідну інформацію про медичні препарати, отримувати та залишати коментарі, оцінювати препарати, а також додавати та переглядати медичні документи.
	Програмою здебільшого будуть користуватися медичні працівники, такі як лікарі та фармацевти, для обміну знаннями та досвідом, а також для пошуку інформації про лікарські засоби. Звичайні користувачі також знайдуть додаток корисним для отримання надійної інформації про ліки та їх застосування. “Medoxity” сприятиме підвищенню якості медичних послуг та ефективності лікування завдяки легкому доступу до актуальної медичної інформації. 
	Крім того, платформа може бути корисною для медичних установ та аптек, які зможуть покращити свої послуги, спираючись на точну та актуальну інформацію про лікарські засоби та обмінюючись досвідом з колегами. Це дозволить їм забезпечити кращий сервіс для пацієнтів та підвищити їх задоволення від отриманих медичних послуг.


	1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДЕМЕТНОЇ ГАЛУЗІ
	1.1 Аналіз предметної області


	Предметною областю є інформація щодо медичних засобів та професійної діяльності медичних працівників, до якої входять наступні фрагменти: 
	–	Інформація про лікарські засоби;
	–	Професійна діяльність лікарів та фармацевтів;
	–   обмін знаннями та досвідом між медичними працівниками;
	–   розвиток професійних мереж;
	–   взаємодія між лікарями, фармацевтами та пацієнтами.
	Фрагмент, що пов’язаний з інформацією про лікарські засоби:
	–	Об’єкт: Лікарський засіб
	–	Процеси: Розробка, реєстрація, застосування
	–	Користувачі: Лікарі, фармацевти, пацієнти
	Інформаційні потреби та результати діяльності кожної групи користувачів та підрозділів: потребує назва, категорія, виробник, діюча речовина, показання до застосування, побічні ефекти; у результаті формується база даних лікарських засобів.
	Загальні характеристики процесів споживання та обробки інформації: інформація про лікарські засоби друкується в електронному вигляді та використовується для поширення серед медичних працівників і пацієнтів.
	Фрагмент, що пов’язаний з професійною діяльністю лікарів та фармацевтів:
	–	Об’єкт: Медичний працівник
	–	Процеси: Реєстрація, обмін знаннями, професійний розвиток
	–	Користувачі: Лікарі, фармацевти
	Інформаційні потреби та результати діяльності кожної групи користувачів та підрозділів: потребує особисті дані, спеціалізація, досвід роботи, наукові публікації; у результаті формується професійний профіль.
	Інформація про медичних працівників зберігається в електронному вигляді та використовується для поширення серед професійної спільноти.
	Фрагмент, що пов’язаний з обміном знаннями та досвідом:
	–	Об’єкт: Інформаційний обмін
	–	Процеси: Створення, обробка, поширення інформації
	–	Користувачі: Лікарі, фармацевти
	Інформаційні потреби та результати діяльності кожної групи користувачів та підрозділів: потребує доступ до медичної інформації, можливість обміну досвідом; у результаті формується база знань та рекомендацій.
	Загальні характеристики процесів споживання та обробки інформації: інформація обробляється в електронному вигляді та використовується для покращення медичних практик.
	Наша мета - створити інноваційну платформу, яка революціонізує спосіб, яким медичні працівники отримують і обмінюються інформацією про лікарські засоби, набуті знання та професійні досвіди. Наша платформа буде відомим місцем для медичної спільноти, де вони зможуть легко знаходити потрібну інформацію, спілкуватися з колегами, обмінюватися найкращими практиками та розвивати свої професійні мережі.
	Наша платформа для медичних працівників буде високоефективним інструментом, що об'єднує усі аспекти їхньої професійної діяльності. Вона буде простою у використанні, інтуїтивно зрозумілою та надійною. Ми прагнемо створити середовище, де медичні фахівці зможуть легко знаходити необхідну інформацію про лікарські засоби, ділитися своїми знаннями та досвідом, а також розширювати свої професійні зв'язки. Наша платформа покликана полегшити робочий процес медичних працівників та сприяти підвищенню якості медичної практики
	Наша платформа реагує на різноманітні потреби медичних працівників у полегшенні доступу до інформації, обміні знаннями та розвитку професійних мереж:
	–	Полегшений доступ до інформації про лікарські засоби: Медичні працівники потребують ефективного інструмента для швидкого та зручного пошуку інформації про лікарські засоби, включаючи описи, дозування, побічні ефекти та інші важливі дані;
	–	Обмін знаннями та досвідом: Медичні фахівці мають потребу в платформі, яка дозволяє їм обмінюватися досвідом, розглядати клінічні випадки та найкращі практики, що допомагає підвищити якість медичної практики;
	–	Розвиток професійних мереж: Медичні працівники шукають можливості розвивати свої професійні мережі, знаходити колег та експертів для консультацій та співпраці.
	Поза цими основними потребами, існують додаткові вимоги до нашої платформи, що відповідають наступним реаліям:
	–	Безпека даних: Медичні працівники вимагають, щоб їхні дані були захищені від несанкціонованого доступу та зловживання;
	–	Легкість використання: Платформа повинна бути інтуїтивно зрозумілою та легкою у використанні, щоб медичні працівники могли ефективно використовувати її навіть без спеціальної підготовки;
	–	Надійність: Медичні працівники очікують, що платформа буде доступною та працездатною в будь-який час, оскільки це може вплинути на їхню можливість виконувати свої обов'язки та приймати важливі рішення;
	Наша платформа відповідає цим потребам, надаючи медичним працівникам зручний, безпечний та ефективний інструмент для їхньої професійної діяльності.
	Для успішного впровадження та експлуатації платформи необхідно ретельно вивчити та управляти цими ризиками, розробляючи стратегії мінімізації та управління ризиками для забезпечення успіху проекту:
	Ризик низького прийняття платформи: Хоча існує значна потреба у платформі для медичних працівників, можуть виникнути труднощі з її прийняттям через консервативний характер медичної галузі або недостатню свідомість про переваги цього рішення. Цей ризик може призвести до низької активності користувачів та низької використаності платформи.
	Ризик конкуренції: На ринку вже можуть існувати подібні рішення або можуть виникнути нові конкуренти, що пропонують аналогічні платформи для медичних працівників. Цей ризик може призвести до втрати ринкової частки або необхідності посилення маркетингових зусиль для виокремлення від конкурентів.
	Ризик безпеки даних: Платформа може містити конфіденційну та чутливу інформацію про пацієнтів та медичні дані. Ризик порушення безпеки даних, такий як злам системи або витік інформації, може призвести до великих шкідливих наслідків для довіри користувачів та репутації платформи.
	Ризик технічних проблем: Нестабільна робота платформи, збої в роботі або відмови можуть призвести до втрати доступу до важливої інформації для медичних працівників, що може суттєво вплинути на їхню роботу та надійність платформи.
	Ризик зміни регуляторного середовища: Зміни в законодавстві або регуляторних вимогах у сфері медицини можуть вимагати внесення значних змін у функціонал та процеси платформи, що може призвести до витрат часу та ресурсів на виконання необхідних адаптацій.


	1.2 Аналіз аналогів


	Аналогів небагато, але вони присутні. Серед них можна віділити Doximity.
	Doximity – це одна з провідних професійних мереж для лікарів, яка надає платформу для спілкування, обміну досвідом та доступу до медичної інформації. Основні функції Doximity включають створення та оновлення професійних профілів лікарів, можливість спілкування з колегами через повідомлення та створення професійних контактів, доступ до останніх новин та наукових досліджень у медичній сфері, проведення віртуальних консультацій з пацієнтами, використання клінічних інструментів для перегляду медичних записів і отримання інформації про лікарські засоби, а також можливість давати та отримувати рекомендації від колег.
	Розглянемо веб сторінку Doximity (посилання на вебсайт https://www.doximity.com/ )[1] (див. рис 1.1).  
 
	Рисунок 1.1 – вебсайт Doximity

	Doximity є непоганим вибором для професійної взаємодії та розвитку лікарів, але має певні обмеження, які можна врахувати при розробці альтернативних платформ, для забезпечення більш широкого функціоналу та доступності як для медичних працівників, так і для пацієнтів. Doximity має ряд недоліків. Платформа орієнтована переважно на лікарів, що обмежує можливості взаємодії між лікарями та пацієнтами, оскільки пацієнти не можуть безпосередньо користуватися багатьма функціями платформи. Незважаючи на високий рівень захисту даних, завжди існує ризик порушення конфіденційності та безпеки інформації. Для повноцінного використання платформи потрібне стабільне інтернет-з'єднання, що може бути проблемою в регіонах з низькою якістю мережі. Платформа також має обмежені можливості для обміну великими обсягами даних або досліджень між лікарями. Багато корисних функцій доступні лише у платній версії, що може бути недоступним для молодих лікарів або тих, хто працює в невеликих медичних установах. Крім того, Doximity не завжди 	рівномірно охоплює всі медичні спеціальності, що може обмежувати його корисність для лікарів у менш поширених галузях медицини.


	1.3 Концептуальне моделювання предметної області


	Концептуальне моделювання предметної області для платформи “Medoxity” включає визначення ключових об’єктів та їх взаємозв’язків, що забезпечує ефективне функціонування системи та задоволення інформаційних потреб користувачів. Нижче наведено основні елементи та взаємозв’язки між ними.
	Основні об'єкти:
	–	Користувач (User):
	Атрибути: Ім'я, електронна пошта, пароль, спеціалізація, досвід роботи, наукові публікації.
	Зв'язки: Може мати відношення до лікарських засобів, коментарів, рейтингів, документів, повідомлень.
	–	Лікарський засіб (Drug):
	Атрибути: Назва, категорія, виробник, діюча речовина, показання до застосування, побічні ефекти.
	Зв'язки: Може бути пов’язаний з коментарями, рейтингами, пошуком.
	–	Коментар (Comment):
	Атрибути: Текст коментаря, UserID, DrugID.
	Зв'язки: Прив'язаний до конкретного користувача і лікарського засобу, може мати лайки.
	–	Рейтинг (Rating):
	Атрибути: Оцінка, UserID, DrugID.
	Зв'язки: Прив'язаний до конкретного користувача і лікарського засобу.
	–	Документ (Document):
	Атрибути: Назва, опис, файл, UserID. 
	Зв'язки: Прив'язаний до конкретного користувача.
	–	Повідомлення (Message):
	Атрибути: Текст повідомлення, SenderID, ReceiverID.
	Зв'язки: Прив'язане до відправника і отримувача.
	Розглянемо побудову ER –діаграми для знайомства з структурою бази даних системи(див.рис 1.2).

 
	Рисунок 1.2 – ER–діаграма
	Розгялнемо основні взаємозв’язки:
	–	Користувачі та лікарські засоби: Користувачі можуть залишати коментарі та оцінки до лікарських засобів. Користувачі можуть додавати нові лікарські засоби та редагувати існуючі;
	–	Користувачі та коментарі: Користувачі можуть створювати, переглядати, редагувати та видаляти коментарі. Користувачі можуть ставити лайки до коментарів інших користувачів;
	–	Користувачі та рейтинги: Користувачі можуть створювати, переглядати, редагувати та видаляти рейтинги лікарських засобів;
	–	Користувачі та документи: Користувачі можуть завантажувати, переглядати, редагувати та видаляти документи. Документи можуть бути пов’язані з певними лікарськими засобами або іншими медичними темами;
	–	Користувачі та повідомлення: Користувачі можуть надсилати та отримувати повідомлення від інших користувачів. Повідомлення можуть містити текстову інформацію, що стосується лікарських засобів або інших медичних тем;



2 ПОСТАНОВКА ЗАДАЧІ
	2.1 Опис задачі


	Наша мета - створити інноваційну платформу, яка революціонізує спосіб, яким медичні працівники отримують і обмінюються інформацією про лікарські засоби, набуті знання та професійні досвіди. Наша платформа буде відомим місцем для медичної спільноти, де вони зможуть легко знаходити потрібну інформацію, спілкуватися з колегами, обмінюватися найкращими практиками та розвивати свої професійні мережі.
	Наша платформа для медичних працівників буде високоефективним інструментом, що об'єднує усі аспекти їхньої професійної діяльності. Вона буде простою у використанні, інтуїтивно зрозумілою та надійною. Ми прагнемо створити середовище, де медичні фахівці зможуть легко знаходити необхідну інформацію про лікарські засоби, ділитися своїми знаннями та досвідом, а також розширювати свої професійні зв'язки. Наша платформа покликана полегшити робочий процес медичних працівників та сприяти підвищенню якості медичної практики.


	2.2 Функціональність


	Розділ "Major Features" має на меті описати ключові функціональні можливості платформи “Medoxity”, що забезпечують її основні задачі та відповідають потребам користувачів. Нижче наведено основні функціональні блоки, які будуть реалізовані в системі:
	–  Повний доступ та керування користувачами: Можливість реєстрації та керування користувачами, що дозволяє легко впроваджувати та керувати доступом до платформи для медичних працівників.
	– Пошук та обмін інформацією: Функціонал, який забезпечує легкий пошук інформації про лікарські засоби, а також можливість обміну знаннями та досвідом між лікарями та фармацевтами.
 	– Аналітика та звітність: Можливість отримання статистики та аналітики щодо використання платформи, що допоможе вдосконалити процеси та приймати обґрунтовані рішення.
	– Забезпечення безпеки даних: Автоматичне хешування паролів та зберігання їх у хешованому вигляді у базі даних для забезпечення високого рівня безпеки даних користувачів.
	– Розвиток професійних мереж: Функціонал, що дозволяє медичним працівникам розвивати свої професійні мережі, знаходити колег та експертів для консультацій та співпраці.


	2.3 Припущення та залежності


	Розділ "Припущення та залежності" має на меті визначити ключові передумови та зовнішні фактори, які можуть впливати на реалізацію та успіх платформи “Medoxity”. Це дозволяє краще розуміти обмеження проекту та потенційні ризики, а також забезпечує ясність для всіх зацікавлених сторін:
	– Припущено, що доступ до інформації про лікарські засоби та обмін досвідом буде забезпечений через швидкий та надійний інтернет-зв'язок для медичних працівників.
	– Припущено, що користувачі будуть мати базові навички роботи з комп'ютером та Інтернетом для ефективного використання функціоналу платформи.
	– Припущено, що платформа буде регулярно оновлюватись для впровадження нових функцій та виправлення помилок.
	– Припущено, що всі дані та функції платформи будуть відповідати актуальним нормативним вимогам щодо захисту медичної інформації.
	– Припущено, що медичні заклади підтримуватимуть використання платформи своїми працівниками та сприятимуть її впровадженню.
	– Буде залежність від надійного хостинг-провайдера, який забезпечить стабільну роботу серверів та їх доступність.
	– Буде залежність від змін у законодавстві та нормативних актах, які можуть вимагати внесення змін до функціоналу або процесів платформи.
	– Буде залежність від інтеграцій з зовнішніми сервісами та API для розширення функціональності платформи (наприклад, сервіси для перевірки лікарських засобів, інструменти для аналітики).
	– Буде залежність від команди технічної підтримки, яка забезпечує обслуговування платформи, включаючи вирішення технічних проблем та підтримку користувачів.
	– Буде залежність від фінансових ресурсів для забезпечення безперебійного функціонування платформи, її розвитку та маркетингової підтримки.
	– Буде залежність від систем безпеки для захисту конфіденційної інформації користувачів та запобігання несанкціонованому доступу.


3 СЕРВЕРНА ЧАСТИНА СИСТЕМИ
	3.1 Архітектура


	Архітектуру системи можна зазначити по більшій частині як монолітну, дана архітектура забезпечує легке тестування, більш легку та узгоджену розгортку, більш швидку роботу при взаємодії компонентів. 
	Як сервер використовується фреймворк ASP.NET. Проєкт має багатошарову архітектуру, яка складається з контролерів, моделей, контексту бази даних, конфігураційних файлів та головного файлу програми. Контролери керують логікою обробки запитів від користувачів і повертають відповідні відповіді. Вони викликають методи репозиторіїв для доступу до даних. Моделі, що включають Comment.cs, Document.cs, Drug.cs, Like.cs, Login.cs, Message.cs, Rating.cs, Register.cs та User.cs, представляють структуру даних, які зберігаються в базі даних. Вони використовуються для створення, читання, оновлення і видалення записів у базі даних. Контекст бази даних, представлений MedicalPlatformContext.cs, відповідає за взаємодію з базою даних і містить DbSet-и для кожної моделі, що дозволяє виконувати запити до бази даних. Конфігураційні файли, такі як appsettings.json та appsettings.Development.json, зберігають налаштування, включаючи строки підключення до бази даних, параметри логування та налаштування для зовнішніх сервісів. Головний 		вхідний файл програми, Program.cs, містить метод Main, який є точкою входу для програми, налаштовує веб-сервер і виконує початкову конфігурацію.
	Система представляє собою Web Application, що складається з певних частин системи. Головний з них - це RESTful Web API. Він надає доступ до функціональності платформи для медичних працівників. Ця платформа дозволяє користувачам шукати інформацію про лікарські засоби, обмінюватися знаннями та досвідом, а також розвивати професійні мережі. Система складається з декількох основних компонентів: Models, Controllers, база даних, контекст даних, конфігураційні файли, 
	Сервер буде контактувати з клієнтом через HTTP запити, архітектура сервера та технології його були використані для створення Web API, які повертають дані у форматі JSON, класи контролерів у такому випадку наслідуються від “ControllerBase”. Такий підхід контакту між сервером та іншими частинами платформи забезпечує велику масштабованість та гнучкість.
	База даних використовується для зберігання даних для всієї системи. Це ключовий ресурс системи, бо він має всі важливі та конфіденційні дані, такі як інформація про користувачів, лікарські засоби, коментарі, документи та повідомлення. Забезпечення безпеки бази даних є критичним завданням, оскільки вона зберігає найбільш дорогі активи платформи, для будь-якої платформи регулярні та заплановані резервні копії даних є критично обов’язковою дією. У нашому випадку використовується реляційна база даних MS SQL.
	Комунікація між компонентами проходить, завдяки HTTP. 
	Система складається з таких частин:
	–	Сервер 
	–	Веб частина
	–	Мобільна частина
	Функціонал системи, який взаємодіє з базою даних, оброблює дані, та виконує обчислення знаходиться та виконується на сервері платформи для медико-фармацевтичної колаборації, інші клієнтські частини забезпечують frontend системи, вони приймають та візуалізують дані, які було отримано через сервер завдяки запиту GET. POST запити у клієнтській частині створюють нові дані та роблять запити до інших підвидів функцій приводять до змін у базі даних медичної платформи. PUT запити приводять к зверненню до функції, яка вносить зміни до існуючих даних.


	3.2 Побудова діаграми прецедентів


	У даному застосунку буде представлено 3 актори:
	–	Адміністратор
	–	Працівник
	–	Клієнт
	Веб-платформа дозволяє користувачам здійснювати завантаження своїх медичних даних та ліків, отримати інформацію щодо своїх даних та отримати через платформу допомогу та залишати відгук. Для медичних працівників надається можливість взаємодіяти з замовленнями та контролювати стан лікарських засобів, адміністратору надаються можливості найвищого рівня доступу.
	У діаграмі Use Case було представлено можливості користувачів(див.рис. 3.1).

 
	Рисунок 3.1 – Діаграма прецедентів серверної частини

	Мобільний застосунок надає можливість людям передивитися свої медичні документи та стан здоров’я.
	За допомогою Smart Device користувачі зможуть зрозуміти свій стан здоров’я.


	3.3 Побудова діаграми розгортання


	Давайте розглянемо deployment діаграму (див. рис 3.2), щоб краще зрозуміти, як компоненти системи взаємодіють між собою.

 

	Рисунок 3.2 – Діаграма розгортання

	Ми можемо помітити такі частини системи:
	–	Веб-сервер (C# ASP.NET). Локалізація: Дата-центр або серверний простір. Роль: Забезпечує серверну логіку, обробку запитів та взаємодію з базою даних MS SQL.
	–	База даних (MS SQL). Локалізація: Дата-центр або серверний простір. Роль: Зберігання та управління даними 
	–	Android Клієнтський додаток. Локалізація: Мобільний пристрій (Android). Роль: Надає користувачам зручний інтерфейс для взаємодії з системою, отримання інформації та управління параметрами.
	–	Arduino (Мікроконтролер). Локалізація: Близько до фізичного об'єкта. Роль: Забезпечує збір параметрів контролю.


	3.4 Специфікація REST


	Специфікація REST API надає структурований опис того, як клієнти та сервери взаємодіють між собою в рамках веб-додатку. Оглянемо специфікації REST API:
	–	/users/register (POST):
	Зареєструвати нового користувача. Потрібно передати дані: ім'я, електронну пошту, пароль та інші необхідні дані.
	–	/users/login (POST):
	Увійти в систему. Потрібно передати електронну пошту та пароль.
	–	/users/{userID} (GET):
	Отримати інформацію про конкретного користувача за його унікальним ідентифікатором.
	–	/users/{userID} (PUT):
	Оновити інформацію про конкретного користувача.
	–	/drugs (GET):
	Отримати список всіх лікарських засобів з можливістю фільтрації за назвою, категорією, виробником тощо.
	–	/drugs/{drugID} (GET):
	Отримати детальну інформацію про конкретний лікарський засіб за його унікальним ідентифікатором.
	–	/drugs/search (GET):
	Пошук лікарських засобів за параметрами, такими як назва, речовина, показання до застосування тощо.
	–	/comments (GET):
	Отримати список всіх коментарів до лікарських засобів.
	–	/comment (POST):
	Додати новий коментар до лікарського засобу. Потрібно передати дані: текст коментаря, UserID, DrugID.
	–	/comments/{commentID} (GET):
        Отримати інформацію про конкретний коментар за його унікальним ідентифікатором.
	–	/comments/{commentID} (DELETE):
	Видалити коментар за його унікальним ідентифікатором.
	–	/comments/{commentID}/likes (POST):
	Додати вподобайку до коментаря. Потрібно передати UserID.
	–	/comments/{commentID}/likes (DELETE):
	Видалити вподобайку з коментаря.
	–	/ratings (GET):
	Отримати список всіх рейтингів лікарських засобів.
	–	/ratings (POST):
	Додати новий рейтинг до лікарського засобу. Потрібно передати дані: оцінка, UserID, DrugID.
	–	/ratings/{ratingID} (GET):
	Отримати інформацію про конкретний рейтинг за його унікальним ідентифікатором.
	–	/ratings/{ratingID} (PUT):
	Оновити інформацію про конкретний рейтинг.
	–	/ratings/{ratingID} (DELETE):
	Видалити рейтинг за його унікальним ідентифікатором.
	–	/documents (GET):
	Отримати список всіх документів, доданих користувачами.
	–	/documents (POST):
	Додати новий документ. Потрібно передати дані: назва, опис, файл, UserID.
	–	/documents/{documentID} (GET):
	Отримати інформацію про конкретний документ за його унікальним ідентифікатором.
	–	/documents/{documentID} (PUT):
        Оновити інформацію про конкретний документ.
	–	/documents/{documentID} (DELETE):
	Видалити документ за його унікальним ідентифікатором.
	–	/messages (GET):
	Отримати список всіх повідомлень між користувачами.
	–	/message (POST):
	Надіслати нове повідомлення. Потрібно передати дані: текст повідомлення, SenderID, ReceiverID.
	–	/messages/{messageID} (DELETE):
	Видалити повідомлення за його унікальним ідентифікатором.
	Розглянемо деякі функції, які у контролері MessagesController(див. додаток А).


	3.5 Тестування


	Розділ описує підхід до забезпечення якості платформи “Medoxity” шляхом автоматизованого тестування її функціональних компонентів. Мета тестування полягає у забезпеченні коректної роботи ключових функціональних можливостей платформи, виявленні та усуненні можливих помилок, а також перевірці відповідності функціональності вимогам користувачів. Тестування допомагає гарантувати, що система працює стабільно та надійно.
	Структура тестування включає перевірку основних сервісів платформи, таких як коментарі, документи, лікарські засоби, вподобання, повідомлення, рейтинги та користувачі. Кожен сервіс має набір тестових випадків, що перевіряють різні аспекти його функціональності 
	Розглянемо ручне тестування з функціями, які пов’язані з відправкою повідомлення:
	Введемо дані

	curl -X 'POST' \
	  'https://localhost:7126/api/Messages/message' \
	  -H 'accept: */*' \
	  -H 'Content-Type: application/json' \
	  -d '{
	  "receiverUsername": "john_doe",
	  "text": "bye-bye"
	}'

	Та отримаємо відповідь серверу (див.рис 3.3)

 
	Рисунок 3.3 – Відповідь сервера на запит

	Розглянемо автоматичне тестування з функцій (див.рис 3.4).
	
 
	Рисунок 3.4 – Обозрівач тестів

	Також розглянемо код для класу MessageServiceTest (див. додаток Б).
	

	3.6 Побудова діаграми пакетів 


	Було аналізовано структуру програмного забезпечення. Пакети, які є складовими проекту було виділено на діаграмі пакетів(див. рис 3.5)
	Для реалізації проекту було використано пакет EntityFrameworkCore, EntityFrameworkCore.SqlServer для роботи з MS SQL та EntityFrameworkCore.Tools. У Models у нас зберігаються класи для моделювання сутностей бази даних та обробник помилок.


	Рисунок 3.5 – Діаграма пакетів

 	Діаграма демонструє використання пакетів серверної частини. Використовуються різні компоненти Entity Framework Core для роботи з базою даних, а також розділені моделі, контролери, сервіси для управління бізнес-логікою (Business Logic Layer), репозиторії для доступу для даних(Data Access Layer).


4 IOT ЧАСТИНА СИСТЕМИ
	4.1 Архітектура


	Пристрій збирає дані, такі як частота серцевих скорочень (BPM)  та температура тіла, використовуючи відповідні датчики, і передає їх на сервер через Wi-Fi для подальшого аналізу та зберігання. Проект використовує мікроконтролер WiFIEsp для підключення до інтернету та датчик PulseSensorPlayground для вимірювання пульсу і температури. 
	Ця система складається з трьох основних компонентів:
	–	Модуль збору даних
	–	Модуль передачі даних
	–	Модуль обробки даних
	Програмне забезпечення пристрою включає бібліотеки Arduino: WiFiEsp.h, Wire.h та PulseSensorPlayground.h. Скетч, написаний для збору даних та їх передачі, реалізує логіку збору даних з датчиків та передачі їх на сервер через Wi-Fi. Сервер приймає дані від Smart Device, зберігає їх у базі даних і виконує аналіз для надання корисної інформації користувачу.
	WiFiEsp є економічно вигідним та добре підтримуваним мікроконтролером, що робить його ідеальним для IoT проектів. Він забезпечує стабільне з'єднання з інтернетом і достатню обчислювальну потужність для обробки даних з датчиків.
	PulseSensorPlayground є надійним і точним датчиком для вимірювання частоти серцевих скорочень та рівня кисню в крові, що є ключовими показниками здоров'я. Він легко інтегрується з Arduino та іншими мікроконтролерами.
	Ця архітектура забезпечує надійний та ефективний спосіб збору та передачі даних про стан здоров'я користувача. Використання WiFiEsp та відповідних датчиків дозволяє створити доступний і функціональний пристрій для моніторингу ключових показників здоров'я. Така архітектура підходить для розробки IoT пристроїв з мінімальними витратами та високою точністю вимірювань. ASP.NET Core для реалізації серверної частини, яка приймає та обробляє дані зі Smart Device є чудовим вибором. Це дозволяє скористатися потужними можливостями .NET для обробки запитів та роботи з базою даних.
	

	4.2 Побудова діаграми прецедентів
	
	
	У даному прикладі буде представлено 3 актори(див.рис 4.1):
	–	Користувач з показнимками здоров’я
	–	Smart Device 
	–	Сервер
	Ця діаграма описує прецеденти, які стостуються взаємодії системи зі смарт девайсом та саму роботу девайсу.
	Smart Device виконує замір показників, аналізує та передає дані. Сервер обробляє дані. Замір показників включає вибір підключення, а аналіз даних включає обробку і передачу даних.

	
 
	Рисунок 4.1 – Діаграма прецедентів IoT частини
	
	На діаграмі показані випадки використання для взаємодії користувача з розумним пристроєм. Користувач обирає підключення (Bluetooth або Wi-Fi), оглядає дані та налаштовує пристрій. 


	4.3 Побудова діаграми пакетів


	Діаграма пакетів – інструмент для відображення структури програми, розгляданої на рівні пакетів або модулів. В контексті коду для Arduino, головний файл, наприклад, sketch.ino, можна розглядати як основний пакет.
	Для відображення зв'язків між sketch.ino та іншими файлами, такими як WiFiEsp.h (див.рис. 4.2), доцільно використовувати стрілки "використання" (Use).

 
	Рисунок 4.2 – Діаграма пакетів IoT частини

	Ці стрілки ілюструють, що один пакет використовує функціональність іншого


	4.4 Обробка даних
	
	
	Інформація, яка здобувається завдяки смарт девайсам, також можуть бути передані на сервер.
	Розглянемо приклад, якби оброблялися ці дані:
	
	[HttpPost("calculateaveragepulse")]
public IActionResult CalculateAveragePulse([FromBody] List<SensorData> sensorDataList)
{
    try
    {
        var averagePulse = _arduinoService.CalculateAveragePulse(sensorDataList);
        return Ok(new { AveragePulse = averagePulse });
    }
    catch (ArgumentException ex)
    {
        return BadRequest(new { message = ex.Message });
    }
}

[HttpPost("calculateaveragetemperature")]
public IActionResult CalculateAverageTemperature([FromBody] List<SensorData> sensorDataList)
{
    try
    {
        var averageTemperature = _arduinoService.CalculateAverageTemperature(sensorDataList);
        return Ok(new { AverageTemperature = averageTemperature });
    }
    catch (ArgumentException ex)
    {
        return BadRequest(new { message = ex.Message });
    }
}

	У цьому розділі описано процес обробки даних, отриманих з IoT-пристроїв, таких як сенсори, що збирають дані про пульс та температуру. Приклади коду демонструють, як API контролер обробляє запити на обчислення середніх значень пульсу та температури, переданих у вигляді списку об'єктів SensorData. 


5 ВЕБ ЧАСТИНА СИСТЕМИ
	5.1 Інтерфейс
	
	
	Клієнтський інтерфейс Medoxity спроектований з урахуванням зручності та ефективності взаємодії для користувачів, що працюють у медичній сфері. Основні елементи і функції інтерфейсу включають:
	–	Навігаційний Бар: Розташований у верхній частині екрану, навігаційний бар містить логотип "Medoxity" та основні розділи, такі як "Home", "Direct", "Profile" та "Drugs". Активне посилання виділяється, вказуючи на поточну сторінку, що дозволяє користувачам легко орієнтуватися в системі.
	–	Головний Вміст: Великий контентний блок займає основну частину екрану та відображає конкретний вміст кожної сторінки, який динамічно вставляється через @RenderBody(). Дизайн та розташування елементів дозволяють зосередитися на ключовій інформації та функціоналітеті.
	–	Футер: Розташований у нижній частині екрану, футер містить копірайт "© 2024 - Medoxity" та посилання на розділ "Privacy". Це забезпечує зручний доступ до політики конфіденційності та підсилює відчуття завершеності сторінки.
	–	Адаптивний Дизайн: Інтерфейс підтримує адаптивний дизайн для роботи на різних пристроях та розмірах екрану. Це забезпечує зручний доступ до функціоналу як на комп'ютерах, так і на мобільних пристроях, покращуючи загальний досвід користування платформою.
	–	Вихід із Системи: Включено посилання "LogOut", яке дозволяє користувачам безпечно вийти зі свого облікового запису, забезпечуючи безпеку та конфіденційність даних.
	–	Технології та Інструменти: Для створення інтерфейсу використовується фреймворк ASP.NET Razor Pages, який дозволяє динамічно рендерити сторінки на сервері. Bootstrap забезпечує адаптивність та стилізацію елементів інтерфейсу, тоді як jQuery використовується для інтерактивності та динамічних змін на сторінці.
	Розглянемо сторінку для авторизації(див. рис 5.1):

 
	Рисунок 5.1 – Вікно сторінки авторизації

	Також розглянемо вікно сторінки перегляду повідомлень(див. рис 5.2).

 
	Рисунок 5.2 – Вікно сторінки дірект


	Розглянемо сторінку для перегялду препарату(див. рис 5.3):
 
	Рисунок 5.3 – Сторінка вікна препарату
	На зображенні показана веб-сторінка платформи Medoxity з деталями про препарат Paracetamol. Опис: засіб для зниження температури, виробник: Tylenol, ціна: $8.99, кількість на складі: 150, дата випуску: 20 березня 2023 року.
	Також на сторінці є розділ для додавання рейтингу препарату та розділ з коментарями, де є один коментар від користувача "john_doe" від 18 травня 2024 року. У верхній частині сторінки розташоване навігаційне меню та перемикач мови.


	5.2 Побудова діаграми пакетів


	Було аналізовано структуру клієнтської частини програмного забезпечення (див. рис 5.4). Ця діаграма пакетів ілюструє організацію фронтенду ASP.NET програми, яка використовує шаблон Layout для створення єдиної структури інтерфейсу. Головний пакет «Pages» включає в себе кілька файлів і підпакет «Shared», який містить загальні компоненти для всієї програми. Пакет «Shared» містить файли _Layout.cshtml, який забезпечує уніфікований дизайн та структуру всіх сторінок, _ValidationScriptsPartial.cshtml для валідації скриптів, _ViewImports.cshtml для імпорту необхідних просторів імен та _ViewStart.cshtml, який задає загальні налаштування для всіх сторінок у цьому пакеті. 
	Основні сторінки включають Admin.cshtml для керування платформою адміністратора, Direct.cshtml для перегялду списку діалогів, Drug.cshtml для перегляду детальної інформації про конкретний медичний препарат, Drugs.cshtml зі списком медичних препаратів, Index.cshtml як головну сторінку платформи, Login.cshtml для входу користувачів до системи, Messages.cshtml для перегляду та відправки повідомлень між користувачами та Profile.cshtml для профілю користувача..

 
	Рисунок 5.4 – Діаграма пакетів веб частини

	Ця структура забезпечує логічний поділ функціоналу та дозволяє ефективно організувати роботу над проектом, розділяючи загальні компоненти та специфічні сторінки.
	

6  МОБІЛЬНА ЧАСТИНА СИСТЕМИ
	6.1 Архітектура та інтерфейс
	
	
	Мобільний клієнт робить запит до серверу, та отримує від нього дані та відповідь.
	Мобільний додаток взаємодіє з сервером для отримання та відправлення даних. Ця взаємодія включає виконання HTTP-запитів до серверного API. У цьому розділі ми розглянемо інженерні та архітектурні рішення, прийняті для забезпечення надійної та ефективної комунікації між мобільним додатком та сервером.
	OkHttp є потужною бібліотекою для виконання HTTP-запитів, яка забезпечує ефективну обробку запитів та відповідей. Переваги: Легкість інтеграції, висока продуктивність, підтримка асинхронних запитів, простота налаштування.
	Використання асинхронних запитів дозволяє виконувати HTTP-запити у фоновому режимі, не блокуючи основний потік додатка. Переваги: Підвищення продуктивності та швидкості реакції інтерфейсу користувача, забезпечення кращого користувацького досвіду.
	Структура додатка поділена на логічні пакети, кожен з яких відповідає за певну функціональність. Зокрема, пакет ui відповідає за інтерфейс користувача, пакет model за моделі дані. Використання патерну MVVM для розділення логіки представлення (View) від логіки бізнесу та даних (Model) за допомогою проміжного шару ViewModel. 
	Для передачі даних між мобільним додатком та сервером використовується JSON (JavaScript Object Notation), що є стандартним форматом для обміну даними в веб-додатках. Використання бібліотеки Gson дозволяє легко перетворювати Java об'єкти в JSON і назад.
	Функціональність коду розбито на Activity
	Розгялнемо код для MainActivity (див. додаток В)
	Розглянемо код DirectActivity для перегляду діалогів та надсилання листу, які виконуються при взаємодії з мобільним клієнтом (див. додаток Г):
	Розглянемо вікно для перегляду діалогів та надсилання листу, які виконуються при взаємодії з мобільним клієнтом (див. рис 6.1)
	
 
	Рисунок 6.1 – Вікно для перегляду діалогів та надсилання листу
	
	Розглянемо вікно для перегляду препаратів, які виконуються при взаємодії з мобільним клієнтом (див. рис 6.2)

 
	Рисунок 6.2 – Вікно для перегляду препаратів

	Інтерфейс мобільного додатку для обміну повідомленнями включає інформаційний блок з даними про користувача.

	
	6.2 Побудова діаграми прецедентів
	

	Мобільний застосунок розраховано для адміністартора, який зможе робити дії, які представлені у діаграмі прецедентів(додаток Б)
 	Логін:
	–	Опис: Користувач вводить свої облікові дані для аутентифікації та доступу до мобільного додатка.
	–	Взаємодія: Це початкова точка входу в систему, після успішного логіну користувач отримує доступ до панелі мобільного додатка.
	Панель мобільного додатка:
	–	Опис: Головний екран додатка, з якого користувач може переходити до інших функцій, таких як перегляд документів, препаратів, діалогів та надсилання повідомлень.
	–	Включає: Перегляд документів, Перегляд препаратів, Перегляд діалогів, Надіслати повідомлення.
	Перегляд документів:
	–	Опис: Користувач може переглядати різні документи, доступні в додатку.
	–	Взаємодія: Ця функція є частиною панелі мобільного додатка і включається нею.
	Перегляд препаратів:
	–	Опис: Користувач може переглядати інформацію про різні препарати.
	–	Взаємодія: Ця функція є частиною панелі мобільного додатка і включається нею.
	Перегляд діалогів:
	–	Опис: Користувач може переглядати свої діалоги та історію повідомлень.
	–	Взаємодія: Ця функція є частиною панелі мобільного додатка і включається нею.
	Надіслати повідомлення:
	–	Опис: Користувач може надсилати повідомлення іншим користувачам додатка.
	–	Взаємодія: Ця функція є частиною перегляду діалогів і включається нею.
	
	
	6.3 Побудова діаграми діяльності


	Користувач мобільним додатком, робить певну діяльність, користуючись додатком(див. рис. 6.3).

	Рисунок 6.3 – Діаграма діяльності мобільної частини

	Діаграма діяльності зображує процес використання програми і складається з  етапів. Користувач розпочинає процес з входу в додаток, після чого проходить процес аутентифікації, де система перевіряє його облікові дані. Після успішної аутентифікації користувач потрапляє на головний екран додатка. Звідти він може переглядати список діалогів і вибрати можливість відправити повідомлення або лист. На завершення користувач має можливість залишити відгук про використання додатка.


	6.4 Побудова діаграми пакетів


	Мобільний додаток організований у декілька логічних пакетів, кожен з яких відповідає за певну функціональність додатку. Нижче наведено структуру пакетів, яку можна візуалізувати у вигляді діаграми.
	Діаграма пакетів відображає структуру та організацію різних компонентів у нашому додатку. Нижче подано опис кожного пакету (див.рис. 6.4).

 
	Рисунок 6.4 – Діаграма діяльності мобільної частини
	Пакети мобільного додатку:
	–   model. Призначення: Містить моделі даних, які використовуються в мобільному додатку. Класи: Comment, Document, Drug, Login, Message, UserMessage.
	–   ui. Призначення: Містить активності та фрагменти, які відповідають за відображення даних та взаємодію з користувачем. Класи: CommentActivity, DirectActivity, DocumentActivity, DrugActivity, LoginActivity, MainActivity, MessageActivity.
	–	res. Призначення: Містить ресурси додатку, такі як зображення, макети, меню, значки та інші XML-файли. Підпакети: drawable, layout, menu, mipmap, navigation, values, xml.
	

ВИСНОВКИ


Проєкт "Medoxity" спрямований на створення інноваційної платформи для медичних працівників та звичайних користувачів, що забезпечує швидкий та ефективний доступ до медичної інформації. Ця платформа є інструментом для покращення медичного обслуговування та оперативності прийняття рішень завдяки доступу до актуальних даних про лікарські засоби, обміну знаннями та досвідом, а також розвитку професійних мереж. Платформа надає повну інформацію про лікарські засоби, їх показання, побічні ефекти, дозування та виробників. Електронна база даних спрощує пошук необхідної інформації для лікарів, фармацевтів та звичайних користувачів.
Вона також сприяє обміну знаннями та досвідом між медичними працівниками, що допомагає покращувати медичні практики та підвищувати якість обслуговування. Розвиток професійних мереж через можливість взаємодії з колегами, участь у дискусіях та консультаціях також є важливою частиною платформи. Надійність системи забезпечується через захист даних користувачів від несанкціонованого доступу та зловживання. Стабільна та безперебійна робота платформи гарантує доступність інформації в будь-який час. 
Платформа дозволяє медичним установам та аптекам покращувати свої послуги завдяки точній та актуальній інформації про лікарські засоби, забезпечуючи кращий сервіс для пацієнтів та підвищуючи їх задоволення від медичних послуг. Вона також готова до змін у законодавстві та регуляторних вимогах, що дозволяє швидко адаптуватися до нових умов. 
У рамках проєкту було виконано певні інженерні рішення для забезпечення високої продуктивності та надійності платформи "Medoxity". 
Застосовано архітектурний підхід, який включає модульність, масштабованість та інтеграцію з існуючими системами охорони здоров’я. Це дозволяє забезпечити легкість у використанні, швидкий доступ до даних та високий рівень безпеки. Можливі ризики, такі як низьке прийняття платформи через консервативний характер медичної галузі або недостатню свідомість про переваги рішення, конкуренція з існуючими та потенційними конкурентами, ризик порушення безпеки даних, злам системи або витік інформації, а також нестабільна робота платформи, можуть вплинути на її успіх. Проте, ці ризики можна мінімізувати завдяки активним маркетинговим зусиллям, унікальним функціям платформи та високому рівню обслуговування. Таким чином, проєкт "Medoxity" є високоефективним, безпечним та зручним інструментом, що задовольняє потреби медичних працівників та звичайних користувачів у доступі до медичної інформації, обміні знаннями та розвитку професійних мереж. 

	
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


	1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
	2. Steve McConnell. Code Complete. – Microsoft Press, 2004. – 952 p.
	3. Doximity
	URL: https://www.doximity.com/ (дата звернення: 08.06.2024)
	4. Martin Fowler. Refactoring. Improving the Design of Existing Code– Addison-Wesley Professional, 1999. – 464 p.


ДОДАТОК А
MessagesController


1.  [HttpPost("message")]
2.  [Authorize]
3.  public async Task<IActionResult> SendMessage([FromBody] SendMessageRequest request)
4.  {
5.      var senderUsername = User.FindFirstValue(ClaimTypes.NameIdentifier);
6.  
7.      if (string.IsNullOrEmpty(senderUsername))
8.      {
9.          return Unauthorized(new { message = "User is not authenticated." });
10.     }
11. 
12.     var receiverUser = await _userService.GetCurrentUserAsync(request.ReceiverUsername);
13.     if (receiverUser == null)
14.     {
15.         return NotFound(new { message = "Receiver not found." });
16.     }
17. 
18.     try
19.     {
20.         await _messageService.SendMessageAsync(senderUsername, request.ReceiverUsername, request.Text);
21.         return Ok(new { message = "Message sent successfully." });
22.     }
23.     catch (Exception ex)
24.     {
25.         return BadRequest(new { message = ex.Message });
26.     }
27. }
28. 
29. [HttpGet("messages/{receiverUsername}")]
30. public async Task<ActionResult<IEnumerable<Message>>> GetMessagesBetweenUsers(string receiverUsername)
31. {
32.     var username = User.FindFirstValue(ClaimTypes.NameIdentifier);
33. 
34.     if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(receiverUsername))
35.     {
36.         return BadRequest(new { message = "SenderUsername and ReceiverUsername must be provided." });
37.     }
38. 
39.     var messages = await _messageService.GetMessagesBetweenUsersAsync(username, receiverUsername);
40. 
41.     if (messages == null || !messages.Any())
42.     {
43.         return NotFound(new { message = "No messages found between the specified users." });
44.     }
45. 
46.     return Ok(messages);
47. }
48. 
49. [Authorize(Policy = "AdminPolicy")]
50. [HttpGet("all")]
51. public async Task<IActionResult> GetAllMessages()
52. {
53.     var messages = await _messageService.GetAllMessagesAsync();
54.     return Ok(messages);
55. }
56. 
57. [HttpGet("users-with-messages")]
58. public async Task<IActionResult> GetUsersWithMessages()
59. {
60.     var username = User.FindFirstValue(ClaimTypes.NameIdentifier);
61. 
62.     if (string.IsNullOrEmpty(username))
63.     {
64.         return Unauthorized(new { message = "User is not authenticated." });
65.     }
66. 
67.     var usersWithLastMessages = await _messageService.GetUsersWithMessagesAsync(username);
68.     var result = usersWithLastMessages.Select(uwlm => new
69.     {
70.         User = uwlm.User,
71.         LastMessage = uwlm.LastMessage.Text,
72.         SentDate = uwlm.LastMessage.SentDate
73.     });
74. 
75.     return Ok(result);
76. }


ДОДАТОК Б
MessageServiceTest


1.  public class MessageServiceTests
2.  {
3.      private readonly Mock<IMessageRepository> _mockMessageRepository;
4.      private readonly MessageService _messageService;
5.  
6.      public MessageServiceTests()
7.      {
8.          _mockMessageRepository = new Mock<IMessageRepository>();
9.          _messageService = new MessageService(_mockMessageRepository.Object);
10.     }
11. 
12.     [Fact]
13.     public async Task SendMessageAsync_ValidData_MessageSent()
14.     {
15.         // Arrange
16.         var senderUsername = "sender";
17.         var receiverUsername = "receiver";
18.         var text = "Hello!";
19. 
20.         // Act
21.         await _messageService.SendMessageAsync(senderUsername, receiverUsername, text);
22. 
23.         // Assert
24.         _mockMessageRepository.Verify(repo => repo.AddMessageAsync(It.Is<Message>(
25.             m => m.SenderUsername == senderUsername &&
26.                  m.ReceiverUsername == receiverUsername &&
27.                  m.Text == text)), Times.Once);
28.     }
29. 
30.     [Fact]
31.     public async Task GetMessagesBetweenUsersAsync_MessagesExist_ReturnsMessages()
32.     {
33.         // Arrange
34.         var senderUsername = "sender";
35.         var receiverUsername = "receiver";
36.         var messages = new List<Message>
37.     {
38.         new Message { SenderUsername = senderUsername, ReceiverUsername = receiverUsername, Text = "Hello!" },
39.         new Message { SenderUsername = receiverUsername, ReceiverUsername = senderUsername, Text = "Hi!" }
40.     };
41. 
42.         _mockMessageRepository.Setup(repo => repo.GetMessagesBetweenUsersAsync(senderUsername, receiverUsername))
43.             .ReturnsAsync(messages);
44. 
45.         // Act
46.         var result = await _messageService.GetMessagesBetweenUsersAsync(senderUsername, receiverUsername);
47. 
48.         // Assert
49.         Assert.NotNull(result);
50.         Assert.Equal(2, result.Count());
51.         Assert.Contains(result, m => m.Text == "Hello!");
52.         Assert.Contains(result, m => m.Text == "Hi!");
53.     }
54. 
55.     [Fact]
56.     public async Task GetMessagesBetweenUsersAsync_NoMessagesExist_ReturnsEmptyList()
57.     {
58.         // Arrange
59.         var senderUsername = "sender";
60.         var receiverUsername = "receiver";
61. 
62.         _mockMessageRepository.Setup(repo => repo.GetMessagesBetweenUsersAsync(senderUsername, receiverUsername))
63.             .ReturnsAsync(new List<Message>());
64. 
65.         // Act
66.         var result = await _messageService.GetMessagesBetweenUsersAsync(senderUsername, receiverUsername);
67. 
68.         // Assert
69.         Assert.NotNull(result);
70.         Assert.Empty(result);
71.     }
72. }


ДОДАТОК В
MainActivity.kt


1. class MainActivity : AppCompatActivity() {
2. 
3.     private lateinit var binding: ActivityMainBinding
4. 
5.     override fun onCreate(savedInstanceState: Bundle?) {
6.         super.onCreate(savedInstanceState)
7.         binding = ActivityMainBinding.inflate(layoutInflater)
8.         setContentView(binding.root)
9. 
10.        binding.openDrugActivityButton.setOnClickListener {
11.            val intent = Intent(this, DrugActivity::class.java)
12.            startActivity(intent)
13.        }
14. 
15.        binding.openDirectActivityButton.setOnClickListener {
16.            val intent = Intent(this, DirectActivity::class.java)
17.            startActivity(intent)
18.        }
19. 
20.        binding.openCommentActivityButton.setOnClickListener {
21.            val intent = Intent(this, CommentActivity::class.java)
22.            startActivity(intent)
23.        }
24.        binding.openDocumentActivityButton.setOnClickListener {
25.            val intent = Intent(this, DocumentActivity::class.java)
26.            startActivity(intent)
27.        }
28.    }
29. }


ДОДАТОК Г
DirectActivity.kt


1.  class DirectActivity : AppCompatActivity() {
2.  
3.      private lateinit var directTextView: TextView
4.      private lateinit var receiverUsernameEditText: EditText
5.      private lateinit var messageEditText: EditText
6.      private lateinit var sendMessageButton: Button
7.  
8.      override fun onCreate(savedInstanceState: Bundle?) {
9.          super.onCreate(savedInstanceState)
10.         setContentView(R.layout.activity_direct)
11. 
12.         directTextView = findViewById(R.id.directTextView)
13.         receiverUsernameEditText = findViewById(R.id.receiverUsernameEditText)
14.         messageEditText = findViewById(R.id.messageEditText)
15.         sendMessageButton = findViewById(R.id.sendMessageButton)
16. 
17.         val username = getUsername()
18.         if (username != null) {
19.             makeHttpRequest(username)
20.         } else {
21.             directTextView.text = "No username found. Please login first."
22.         }
23. 
24.         sendMessageButton.setOnClickListener {
25.             val receiverUsername = receiverUsernameEditText.text.toString()
26.             val message = messageEditText.text.toString()
27.             if (receiverUsername.isNotEmpty() && message.isNotEmpty()) {
28.                 sendMessage(username, receiverUsername, message)
29.             } else {
30.                 directTextView.text = "Please enter both receiver username and message."
31.             }
32.         }
33.     }
34. 
35.     private fun getUsername(): String? {
36.         val sharedPreferences = getSharedPreferences("MyAppPreferences", Context.MODE_PRIVATE)
37.         return sharedPreferences.getString("username", null)
38.     }
39. 
40.     private fun makeHttpRequest(username: String) {
41.         val client = getUnsafeOkHttpClient()
42. 
43.         val url = "https://10.0.2.2:7126/api/Mobile/users-with-messages/$username"
44.         val request = Request.Builder()
45.             .url(url)
46.             .build()
47. 
48.         client.newCall(request).enqueue(object : Callback {
49.             override fun onFailure(call: Call, e: IOException) {
50.                 Log.e("DirectActivity", "HTTP request failed: ${e.message}")
51.                 runOnUiThread {
52.                     directTextView.text = "HTTP request failed: ${e.message}"
53.                 }
54.             }
55. 
56.             override fun onResponse(call: Call, response: Response) {
57.                 response.use {
58.                     if (!response.isSuccessful) {
59.                         Log.e("DirectActivity", "HTTP request failed: ${response.message}")
60.                         runOnUiThread {
61.                             directTextView.text = "HTTP request failed: ${response.message}"
62.                         }
63.                         return
64.                     }
65. 
66.                     val responseBody = response.body?.string()
67.                     if (responseBody != null) {
68.                         val gson = Gson()
69.                         val listType = object : TypeToken<List<UserMessage>>() {}.type
70.                         val userMessages: List<UserMessage> = gson.fromJson(responseBody, listType)
71. 
72.                         runOnUiThread {
73.                             directTextView.text = userMessages.joinToString(separator = "\n\n") { message ->
74.                                 "User: ${message.user}\nLastMessage: ${message.lastMessage}\nDate: ${message.sentDate}"
75.                             }
76.                         }
77.                     } else {
78.                         Log.e("DirectActivity", "Response body is null")
79.                         runOnUiThread {
80.                             directTextView.text = "Response body is null"
81.                         }
82.                     }
83.                 }
84.             }
85.         })
86.     }
87. }


ДОДАТОК Д
Результат перевірки на плагіат

Рисунок Д.1 - Перевірка на плагіат